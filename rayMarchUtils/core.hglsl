#pragma once
#include <rayMarchUtils/utils.hglsl>

/* 3d Camera */

struct Camera3D{
    float zoom;
    vec3 lookAt;
    vec3 rayOrigin;
    vec3 upWorld;
};

/*
	Returns rayDirection wrt to the screen
	Consider the screen as the viewing window
*/
vec3 getCamera3DRay(Camera3D cam) {

	float zoom = cam.zoom;
	vec3 ro = cam.rayOrigin;
	vec3 lookat = cam.lookAt;
	vec3 u_world = cam.upWorld;
    vec2 screen = getPixelNormalized();

	vec3 f = normalize(lookat-ro);
	vec3 r = cross(u_world,f);
	vec3 u = cross(f,r);

	vec3 c = ro + f*zoom;
	vec3 i = c + screen.x*r + screen.y*u;

	vec3 rd = normalize(i-ro);

    return rd;
}

/* 3d Camera End */


/* Ray March Core */

#define MAX_DIST        100.
#define MAX_STEPS       100
#define SURF_DIST       .01


float GetDist(vec3 p){
	vec4 s = vec4(0.,1.,6.,1.);
	vec4 s2 = vec4(2.1,1.,6.,1.);

	float sphereDist = length(p-s.xyz) - s.w;
	float sphereDist2 = length(p-s2.xyz) - s2.w;
	float planeDist = p.y;

	float d = min(min(sphereDist,planeDist),sphereDist2);

	return d;

}

vec3 GetNormal(vec3 p){
	float d = GetDist(p);
	vec2 e = vec2(0.01,0.);

	vec3 n = d- vec3(
			GetDist(p-e.xyy),
			GetDist(p-e.yxy),
			GetDist(p-e.yyx));

	return normalize(n);
}


float RayMarch(vec3 ro,vec3 rd){
	float dO = 0;

	for(int i=0;i<MAX_STEPS;i++){
		vec3 p = ro+rd*dO;
		float dS = GetDist(p);
		dO += dS;
		if(dO > MAX_DIST || dS < SURF_DIST) break;
	}

	return dO;
} 

float GetLight(vec3 p){
	vec3 lightPosition = vec3(0.,5.,6.);
	float t = u_Time*2.;
	lightPosition.xz = vec2(3.*sin(t),2.*cos(t));
	vec3 l = normalize(lightPosition-p);
	vec3 n = GetNormal(p);

	float diff = clamp(dot(n,l),0.,1.);

	float d = RayMarch(p+n*SURF_DIST*1.2,l);
	if (d<length(lightPosition-p)) diff *= .1;

	return diff;
}



/* Ray March Core End */