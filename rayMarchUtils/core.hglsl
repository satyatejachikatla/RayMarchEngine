#pragma once
#include <rayMarchUtils/utils.hglsl>

struct RayMarchSettings {
	int MAX_STEPS;
	float MAX_DIST;
	float SURF_DIST;

	vec3 lightSource;
};

struct Camera3D{
	float zoom;
	vec3 lookAt;
	vec3 rayOrigin;
	vec3 upWorld;
};

RayMarchSettings getDefaultRayMarchSettings(){
	RayMarchSettings rayMarchSettings;

	rayMarchSettings.MAX_DIST  = 100.;
	rayMarchSettings.MAX_STEPS = 100;
	rayMarchSettings.SURF_DIST = .01;

	rayMarchSettings.lightSource = vec3(0.,rayMarchSettings.MAX_DIST,0.);

	return rayMarchSettings;
}

Camera3D getDefaultCamera3D() {
	Camera3D cam;

	// No zoom
	cam.zoom = 1.;

	// Set the camera at -z axis looking towards the origin with mouse input
	cam.lookAt = vec3(0.,0.,0.);
	cam.rayOrigin = vec3(0.,0.,-1.);
	
	// Up of the world will always be y, unless any crazy animation
	cam.upWorld = vec3(0.,1.,0.);

	return cam;
}

/*
	Returns rayDirection wrt to the screen
	Consider the screen as the viewing window
*/
vec3 getCamera3DRay(Camera3D cam) {

	float zoom = cam.zoom;
	vec3 ro = cam.rayOrigin;
	vec3 lookat = cam.lookAt;
	vec3 u_world = cam.upWorld;
	vec2 screen = getPixelNormalized();

	vec3 f = normalize(lookat-ro);
	vec3 r = cross(u_world,f);
	vec3 u = cross(f,r);

	vec3 c = ro + f*zoom;
	vec3 i = c + screen.x*r + screen.y*u;

	vec3 rd = normalize(i-ro);

	return rd;
}

/* Need to define or else will fail to compile */
float GetDist(vec3 p);

vec3 GetNormal(vec3 p){
	float d = GetDist(p);
	vec2 e = vec2(0.01,0.);

	vec3 n = d- vec3(
			GetDist(p-e.xyy),
			GetDist(p-e.yxy),
			GetDist(p-e.yyx));

	return normalize(n);
}


float RayMarch(vec3 ro,vec3 rd,RayMarchSettings rayMarchSettings){
	float dO = 0;

	for(int i=0;i<rayMarchSettings.MAX_STEPS;i++){
		vec3 p = ro+rd*dO;
		float dS = GetDist(p);
		dO += dS;
		if(dO > rayMarchSettings.MAX_DIST || dS < rayMarchSettings.SURF_DIST) break;
	}

	return dO;
} 

float GetLight(vec3 p,RayMarchSettings rayMarchSettings){

	vec3 lightPosition = rayMarchSettings.lightSource;

	vec3 l = normalize(lightPosition-p);
	vec3 n = GetNormal(p);

	float diff = clamp(dot(n,l),0.,1.);

	float d = RayMarch(p+n*rayMarchSettings.SURF_DIST*1.2,l,rayMarchSettings);
	if (d<length(lightPosition-p)) diff *= .1;

	return diff;
}